{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"\n",
    "This module contains the definition of a base class for univariate distributions.\n",
    "\"\"\"\n",
    "\n",
    "from typing import Optional, Union, List\n",
    "from abc import ABC\n",
    "import numpy as np\n",
    "\n",
    "from qiskit.aqua import AquaError\n",
    "from qiskit.aqua.utils.validation import validate_min\n",
    "from qiskit.aqua.components.initial_states import Custom\n",
    "from .uncertainty_model import UncertaintyModel\n",
    "\n",
    "\n",
    "class UnivariateDistribution(UncertaintyModel, ABC):\n",
    "    \"\"\"\n",
    "    This module contains the definition of a base class for univariate distributions.\n",
    "    (Interface for discrete bounded uncertainty models assuming an equidistant grid)\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self,\n",
    "                 num_target_qubits: int,\n",
    "                 probabilities: Optional[Union[List[float], np.ndarray]] = None,\n",
    "                 low: float = 0,\n",
    "                 high: float = 1):\n",
    "        r\"\"\"\n",
    "        Args:\n",
    "            num_target_qubits: Number of qubits it acts on,\n",
    "                has a min. value of 1.\n",
    "            probabilities: Probabilities for different states\n",
    "            low: Lower bound, i.e., the value corresponding to \\|0...0>\n",
    "                (assuming an equidistant grid)\n",
    "            high: Upper bound, i.e., the value corresponding to \\|1...1>\n",
    "                (assuming an equidistant grid)\n",
    "        Raises:\n",
    "            AquaError: num qubits and length of probabilities vector do not match\n",
    "        \"\"\"\n",
    "        validate_min('num_target_qubits', num_target_qubits, 1)\n",
    "        super().__init__(num_target_qubits)\n",
    "        self._num_values = 2 ** self.num_target_qubits\n",
    "        self._probabilities = np.array(probabilities)\n",
    "        self._low = low\n",
    "        self._high = high\n",
    "        self._values = np.linspace(low, high, self.num_values)\n",
    "        if probabilities is not None:\n",
    "            if self.num_values != len(probabilities):\n",
    "                raise AquaError('num qubits and length of probabilities vector do not match!')\n",
    "\n",
    "    @staticmethod\n",
    "    def _replacement():\n",
    "        return 'a qiskit.QuantumCircuit'\n",
    "\n",
    "    @property\n",
    "    def low(self):\n",
    "        \"\"\" returns low \"\"\"\n",
    "        return self._low\n",
    "\n",
    "    @property\n",
    "    def high(self):\n",
    "        \"\"\" returns high \"\"\"\n",
    "        return self._high\n",
    "\n",
    "    @property\n",
    "    def num_values(self):\n",
    "        \"\"\" returns number of values \"\"\"\n",
    "        return self._num_values\n",
    "\n",
    "    @property\n",
    "    def values(self):\n",
    "        \"\"\" returns values \"\"\"\n",
    "        return self._values\n",
    "\n",
    "    @property\n",
    "    def probabilities(self):\n",
    "        \"\"\" returns probabilities \"\"\"\n",
    "        return self._probabilities\n",
    "\n",
    "    def build(self, qc, q, q_ancillas=None, params=None):\n",
    "        \"\"\" build \"\"\"\n",
    "        custom_state = Custom(self.num_target_qubits, state_vector=np.sqrt(self.probabilities))\n",
    "        qc.extend(custom_state.construct_circuit('circuit', q))\n",
    "\n",
    "    @staticmethod\n",
    "    def pdf_to_probabilities(pdf, low, high, num_values):\n",
    "        \"\"\"\n",
    "        Takes a probability density function (pdf), and returns a truncated and\n",
    "        discretized array of probabilities corresponding to it\n",
    "        Args:\n",
    "            pdf (function): probability density function\n",
    "            low (float): lower bound of equidistant grid\n",
    "            high (float): upper bound of equidistant grid\n",
    "            num_values (int): number of grid points\n",
    "        Returns:\n",
    "            list: array of probabilities\n",
    "        \"\"\"\n",
    "        probabilities = np.zeros(num_values)\n",
    "        values = np.linspace(low, high, num_values)\n",
    "        total = 0\n",
    "        for i, _ in enumerate(values):\n",
    "            probabilities[i] = pdf(values[i])\n",
    "            total += probabilities[i]\n",
    "        probabilities /= total\n",
    "        return probabilities, values"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
